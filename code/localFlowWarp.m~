function [NewLocalWindows] = localFlowWarp(WarpedPrevFrame, CurrentFrame, LocalWindows, Mask, Width)
% LOCALFLOWWARP Calculate local window movement based on optical flow between frames.

% WarpedPrevFrame = out
% CurrentFrame = ingImg
% LocalWindows = windows
% Mask = 
% Width = wSize
% Calculate tform
opticFlow = opticalFlowFarneback();
flow = estimateFlow(opticFlow, rgb2gray(WarpedPrevFrame));
windows = LocalWindows;

for i=1:size(windows,2)
    window = windows{i};
    X = round(window.Position(1) - (Width/2));
    Y = round(window.Position(2) - (Width/2));
    XX = X + Width;
    YY = Y + Width;
    if(XX >= size(CurrentFrame, 2))
        XX = size(CurrentFrame, 2);
        X = XX - (Width);
    end
    
    if(YY >= size(CurrentFrame,1))
       YY = size(CurrentFrame,1);
       Y = YY - Width;
    end
    
    Vx = flow.Vx;
    Vy = flow.Vy;
    Vx = Vx(Y:YY, X:XX);
    Vx(window.BgMask == 1) = NaN;
    
    Vy = Vy(Y:YY, X:XX);
    Vy(window.BgMask == 1) = NaN;
    
    avg_Vx = (mean(mean(Vx,2,'omitnan'),1,'omitnan'));
    avg_Vy = (mean(mean(Vy,2,'omitnan'),1,'omitnan'));
    
    if(isnan(avg_Vx))
        avg_Vx = 0;
    end
    
    if(isnan(avg_Vy))
        avg_Vy = 0;
    end
    
    window.Position = [(window.Position(1) + avg_Vx) ...
        (window.Position(2) + avg_Vy)];
    
    windows{i}.Position = window.Position;    
end

t = Width/2;


for i=1:numel(windows)
    pos = windows{i}.Position;
    X = round(pos(1));
    Y = round(pos(2));
    if(X + (Width/2) >= size(CurrentFrame,2))
        Y = size(CurrentFrame,1) - (Width/2);
    end
    

end

